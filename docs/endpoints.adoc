= Endpoints

`iamid-provider` code doesn't contain a default implementation for the interactions endpoints login and consent, this is because the interactions process can contain very different steps depending of the specific requirements for the OP server, so it's responsibility of the OP developer to implement the endpoints in the Koa router.

The way to implement this endpoints is creating a https://github.com/koajs/router[koa-router]

== Creating a koa-router

`IamId` app is a Koa app and to implement the endpoints of interaction is needed to create a https://github.com/koajs/router[koa-router], this is the official implementation of a router for koa, as an example to add a login and consent endpoint:

[source,js]
----
const Router = require('koa-router')

class CustomRouter extends extends Router {
  constructor (login) {
    super()

    ... // Omitted concretely implementation

    this
      .post('/login', loginHandler)
      .post('/consent', consentHandler)
  }
}
----

`login` and `consent` will be functions that implement the concrete logic related with each process, but could exist more than one endpoint for each process, for example:

[source,js]
----
  this
    .post('/login/step1', login1)
    .post('/login/step2', login2)
    .post('/consent', consent)
----

Take into account that all this routes will be exposed under the path that is setup for interaction route in configuration (see <<config.adoc#,configurtaion 'routes'>> for more info) so for example with the default config this routes will be:

[source,js]
----
  this
    .post('/login/step1', login1) // /interaction/:interaction_id/login/step1
    .post('/login/step2', login2) // /interaction/:interaction_id/login/step2
    .post('/consent', consent) // /interaction/:interaction_id/consent
----

Is up to the OP developer to implement as many interaction endpoint as needed and synchronize this logic with the OP interface/webapp, as long as this endpoints at the end of each process communicate the result to `iamid-provider` using the services method described in next sections.

== Login endpoint

In this endpoints (or endpoints) the OP server should provide to the user the way to authenticate into the system, usually this will be a remote system and this endpoint should acts as a proxy for execute some type of oauth flow or a direct call to some login service outside the OP server.

To execute the login logic a client or connector can be used to authenticate the user against an external API and store the authorization data using the `Users` repository as described in <<usermanagment.adoc#,User authorization data management>> documentation.

Also task related with validate user input should be implement in this endpoint.

After custom logic, successful login into the system and store the Authentication data into `Users` repository the endpoint should call to the service method `processLogin (userId, ctx, next)` to communicate `iamid-provider` that login has finished, this will make the authorization process progress to the next prompt. The method will be exposed in the context received in the koa route, and can be called as:

----
await ctx.iamid.processLogin(userId, ctx, next)
----

As you can see the koa Context `ctx` and `next` callback are passed to the method because from this point the `iamid-provider` will take the control, so the call to the `processLogin` method should be the last statement of our login logic.

An example of a login endpoint implementation can be found in this repository in link:../test/fixtures/reference-interaction-router.js[reference-interaction-router.js] file inside the `login` method.

After call to this method `iamid-provider` will create a session for this user (this means cookies) and user should not login again if try to make another authorization process in less than 15 minutes (or the configured value for the cookies duration). The `userId` value passed to this method should be an unique user identifier that will be stored in the session and also used for obtain the claims value (used to obtain the auth data from `Users` repo).

== Consent endpoint

In this endpoints (or endpoints) the OP server should show clearly to the End User the list of all the claims, scopes and assertions that are being asked by the RP, the OP should ask explicitly to the user for the permission to share this information. After all the process has finished the endpoint should call to the service method `processConsent (consentData, ctx, next)` to communicate to `iamid-provider` that consent process has finished, this will make the authorization process progress to the next prompt. The method will be exposed in the context received in the koa route, and can be called as:

----
await ctx.iamid.processConsent(ctx.request.body, ctx, next)
----

Again as you can see the koa Context `ctx` and `next` callback are passed to the method because from this point the `iamid-provider` will take the control so the call to the `processConsent` method should be the last statement of our custom consent logic.

The parameter `consentData` is a JSON object with the next structure:

----
{
  "id_token": {
    "claims": {
        "claim_name": 0
    },
    "assertions": {
        "claim_name": 0
    }
  },
  "userinfo": {
    // same
  },
  "approved_scopes": ["scope_name"]
}
----

At root level we can have `id_token` or `userinfo` depending of which section have been request by the RP, inside this two object the structure is exactly the same, can exist a `claims` and `assertions`, the first is related with an RP requesting the value of the claim and the second category is for assertion about a claim.
`claims` and `assertions` are object that contain entries which key is a claim name as for example `given_name` and the value is a index of the consented value.

So to indicate accepted claims/assertions the name of the assertion/claim should appear in the object with an existing index. To no accept a claims/assertion the name of the claim/assertion can appear in the object with index -1 or not appear at all.

All this fields are optionals and depend of the RP first request, should be obtained by the OP interface using the `/interaction/:interactionId` endpoint.

Also at root level we can find `approved_scopes` field that is an array of scopes names that are approved by the End-User, the 'openid' scope is mandatory for any kind of claim request and should be sent just with any consent of the end user.

Let us see clearly with an example:

----
{
  "id_token": {
    "claims": {
        "given_name": 0,
        "total_balance": -1,
    },
    "assertions": {
        "given_name": 0
    }
  },
  "userinfo": {
    "claims": {
        "family_name": 0
    }
  },
  "approved_scopes": ["openid"]
}
----

In the previous example:

* Claims 'given_name' and 'family_name' has been accepted.
* Claim 'total_balance' has been not accepted because have a index of -1.
* Assertion 'given_name' has been accepted.
* Assertion 'family_name' has been not accepted because is missing from the object.

There are a special case related with the "assertions", in the `/interaction/:interaction_id` endpoint response the "result" field of the assertion claims only contain the values that match the assertion evaluation, this means that this result can be an empty array and even in this case the user can accept to share this assertion result (a false value), for this reason when indicates the index to an assertion claim the rules is a little different, a -1 means not share and a index >= 0 means to accept, even if the array has no values (is empty) or a index is out of bound.
